![screenshot](./screenshot.png)

В данной задаче мы предлагаем вам написать бота для игры PaperIO.

Перед тем, как читать дальше, попробуйте сами сыграть в игру, вызвав `cargo xtask play`.
Вы играете за зелёный квадратик в левом нижнем углу, управление стрелками.

## 1. Правила игры

Задача сделана по мотивам проходившего в 2019 году соревнования AiCups 4.

Краткие правила:
* Игровое поле имеет размер 31x31 ячеек.
* Каждый из игроков - это квадрат размером с ячейку. Находясь в центре ячейки, игрок может принимать решение, в какую сторону двигаться дальше. При этом нельзя двигаться в направлении, диаметрально противоположном тому, куда игрок двигался на прошлом ходу.
* Перемещаясь вне своей территории, игрок оставляет за собой шлейф. Пересечение шлейфа любым игроком ведёт к поражению того, чей шлейф пересекается.
* Выйдя за пределы своей территории и вернувшись на неё, игрок захватывает территорию, которую очерчивает его шлейф.
* За захватываемую территорию начисляются очки. За каждую захваченную нейтральную ячейку начисляется 1 очко, за ячейку другого игрока - 5 очков.
* Игра продолжается фиксированное количество тиков. Выигрывает игрок, у которого на момент конца игры наибольшее количество очков.

Ваша задача - написать бота, который сможет победить трёх встроенных противников 3 раза подряд.

## 2. Реализация

Вам нужно дописать код в файл `strategy/src/strategy.rs`. Протокол взаимодействия со стратегией следующий:

* Ваша стратегия будет инстанциирована методом `Strategy::new()` один раз.
* На каждый игровой тик, когда стратегия должна принять решение, будет зваться метод `.on_tick`. В качестве аргумента в этот метод передаётся состояние игрового мира. Вам нужно вернуть направление, в котором стратегия желает двигать своего игрока.
* Направления имеют абсолютный смысл. Т.е., например, `Direction::Up` всегда задаёт направление в сторону увеличения y-координаты.

Описание игрового мира задаётся структурой `World` в файле `proto/src/lib.rs`.

Представленные структуры данных реализуют набор методов, которые могут оказаться вам полезны:

* `world.me()` возвращает игрока, которым управляет стратегия.
* `world.iter_enemies()` возвращает итератор по противникам.
* `world.iter_cells()` возвращает итератор по всем клеткам поля.
* `direction.next(clockwise)` возвращает следующее направление по либо против часово стрелки.
* `direction.opposite()` возвращает диаметрально противоположное направление.
* `cell.distance_to(other)` возвращает Манхэттенское расстояние между двумя клетками.
* `cell.direction_to(other)` возвращает направление в сторону другой клетки.
* `cell.iter_neighbors()` возвращает итератор по соседним клеткам, находящимся в пределах игрового поля.
* `cell.adjacent(direction)` возвращает соседнюю клетку в указанном направлении, если она находится в пределах игрового поля, иначе `None`.
* `cell.adjacent_unchecked(direction)` возвращает соседнюю клетку в указанном направлении.
* `cell.in_bounds()` возвращает `true`, если клетка находится в пределах игрового поля.

Вы не обязаны использовать все из перечисленных методов. Если хотите, вы также можете добавлять свои методы к этим структурам.

## 3. Стратегия

Противники, которых вам предстоит одолеть, довольно слабые. Сработает, например, следующий алгоритм:

1. Находясь на своей территории, переберите все возможные прямоугольники, у которых вы сейчас находитесь в углу и которые не выходят за границы игрового поля.
2. Оцените каждый такой прямоугольник. Формулу оценки можно взять такую:

	`rectangle_score = cells_score - danger^2`

    Здесь:
    * `cells_score` - кол-во очков, которое вам принесёт захватываемая этим прямоугольником территория.
    * `danger` - длина периметра прямоугольника минус текущее минимальное расстояние врага до ячейки периметра этого прямоугольника.

3. Запомните наилучший прямоугольник и сделайте шаг по его периметру. Помните, что вы не можете начать двигаться в направлении, диаметрально противоположном тому, в котором вы двигались на прошлом ходу.

4. Если на новом ходу вы снова оказались на своей территории, проделайте алгоритм снова. Если вы не на своей территории, продолжайте двигаться по периметру прямоугольника с прошлого хода.

Можно заметить, что предложенный выше алгоритм работает за O(N^4). Но поле маленькое, а Rust быстрый, так что тут не предлагается ничего оптимизироать :)

Вещи, которые можно дополнительно попробовать:

* Покрутите значения констант.
* Чтобы сделать стратегию более смелой, добавьте штраф прямоугольникам, которые не захватывают новую территорию.
* Чтобы сделать стратегию более агрессивной, добавьте в оценку бонус за пересечение чужого шлейфа.

Для вдохновения можете почитать пост с разбором топ-2 стратегии: [История второго места в Mini AI Cup 4: Paper IO](https://habr.com/ru/articles/466597/).

## 4. Структура проекта

Данный проект состоит из следующих частей:

* `server` - Сервер, общается с клиентами по TCP. Параметры можно узнать через `cargo run --release -- --help`.
* `gui` - Графический клиент. Вы его уже видели, если запустили `cargo xtask play`. Может так же испольоваться для наблюдения за игрой ботов. Параметры можно узнать аналогичным образом.
* `proto` - Протокол общения клиентов и сервера, здесь лежат структуры, которыми они обмениваются.
* `strategy` - Клинет-бот, непосредственно Ваше домашнее задание :)
* `wasm-launcher` - Лаунчер WASM-ботов. Подробнее об этом чуть ниже.

Доступные рецепты `xtask`:

* `cargo xtask play` - поиграть самому.
* `cargo xtask watch` - собирает стратегию в релизной сборке, запускает игру против трёх встроенных противников и графический интерфейс для наблюдения за игрой.
* `cargo xtask challenge` - проверяет ваше решение. Делает тоже, что и предыдущий рецепт, но запускает три игры подряд и без графического интерфейса.

Все эти рецепты, всего лишь обертка в виде запуска `server`, `strategy`, `wasm-launcher` и `gui` в разных сочетаниях и последовательностях.
Не бойтесь запускать их руками самостоятельно! Вы можете, например, сразиться со своим же ботом или поиграть со своими друзьями. 

## Запуск WASM-файлов

Вы могли заметить, что встроенные стратегии лежат в папке `bots/` как wasm-файлы. Вы тоже можете скомпилировать свою стратегию в wasm и поделиться ей с друзьями.
Для этого в папке со своим решением `strategy`:

1. Поставьте необходимые инструменты сборки: `rustup target add wasm32-wasi`
2. Соберите свою стратегию: `cargo build --release --target wasm32-wasi`
3. Артефакт сборки будет лежать по пути `target/wasm32-wasi/release/paperio-bot.wasm`

Для запуска такой стратегии в папке `wasm-launcher` выполните `cargo run --release -- <путь до wasm файла>`.
Дополнительные параметры можно узнать через `cargo run --release -- --help`

Напомним, что по кодексу чести ШАД вы не можете делиться исходным кодом своего решения. Но wasm-файл не является исходным кодом, так что скомпилированной в wasm стратегией можно делиться без проблем :)
